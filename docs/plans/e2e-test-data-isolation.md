# E2E Test Data Isolation

## Summary
Implement test data setup and teardown for E2E tests to achieve isolation. Each feature file will have its own test data created before tests run and cleaned up after. Uses clean architecture with Repository and Builder patterns.

## Requirements
- [x] TEST-ISO-001: Feature-level test data setup - `beforeAll` hook creates required test data in Airtable with "TEST-" prefix
- [x] TEST-ISO-002: Feature-level test data teardown - `afterAll` hook deletes all test data created for that feature
- [x] TEST-ISO-003: Background verifies data - Background step confirms test data exists, doesn't create it
- [x] TEST-ISO-004: Concrete scenario examples - Feature file uses real test data names in steps
- [x] TEST-ISO-005: Stale data cleanup - Cleanup stale TEST- data before creating new data (handles crashed runs)

## Architecture Approach
**Clean Architecture with Repository + Builder patterns**

Chosen for:
- Clear separation of concerns (Infrastructure → Repository → Builder → Fixtures)
- Maintainability and testability
- Reusable across multiple feature files
- Easy to extend for future test data needs

```
┌─────────────────────────────────────────────────────────────┐
│                    Playwright Test Worker                    │
├─────────────────────────────────────────────────────────────┤
│  ┌────────────────────────────────────────────────────────┐ │
│  │         Test Files (*.spec.ts generated by BDD)        │ │
│  └────────────────┬───────────────────────────────────────┘ │
│  ┌────────────────▼───────────────────────────────────────┐ │
│  │          Test Data Fixtures (Worker Scope)             │ │
│  │  - beforeAll: cleanup stale data, create test data     │ │
│  │  - afterAll: cleanup created data                      │ │
│  └────────────────┬───────────────────────────────────────┘ │
│  ┌────────────────▼───────────────────────────────────────┐ │
│  │              Test Data Builder (Fluent API)            │ │
│  │  - domain() → subdomain() → capability() → requirement()│
│  └────────────────┬───────────────────────────────────────┘ │
│  ┌────────────────▼───────────────────────────────────────┐ │
│  │          Test Data Repository (Business Logic)         │ │
│  │  - CRUD operations for all entity types                │ │
│  │  - cleanupStaleTestData()                              │ │
│  └────────────────┬───────────────────────────────────────┘ │
│  ┌────────────────▼───────────────────────────────────────┐ │
│  │         Airtable Client (Infrastructure Layer)         │ │
│  │  - create, delete, list, batchDelete                   │ │
│  └────────────────┬───────────────────────────────────────┘ │
└───────────────────┼───────────────────────────────────────────┘
                    ▼
        ┌───────────────────────┐
        │   Airtable REST API   │
        └───────────────────────┘
```

## Codebase Patterns
- Playwright fixture extension: `tests/e2e/fixtures/test.ts:10-19`
- Airtable fetch pattern: `src/lib/airtable.ts:30-43`
- Type definitions: `src/types/airtable.ts`
- BDD step definitions: `tests/e2e/steps/*.ts` using `createBdd()`

## Implementation Steps

### Step 1: Create Type Definitions
**Implements**: TEST-ISO-001
**Files**:
- `tests/e2e/types/test-data.types.ts` - Create new file with:
  - `CreateDomainInput`, `CreateSubdomainInput`, `CreateCapabilityInput`, `CreateRequirementInput`
  - `TestDataSet` - Contains all created IDs and domain objects
  - `TestDataIds` - For cleanup tracking

```typescript
// tests/e2e/types/test-data.types.ts
import type { RequirementStatus, RequirementPriority } from "@/types/airtable"

export interface CreateDomainInput {
  name: string
  description?: string
}

export interface CreateSubdomainInput {
  name: string
  domainId: string
  prefix?: string
  description?: string
}

export interface CreateCapabilityInput {
  name: string
  subdomainId: string
  prefix?: string
  description?: string
}

export interface CreateRequirementInput {
  reqId: string
  title: string
  capabilityId: string
  status?: string // Norwegian status value
  priority?: RequirementPriority
  description?: string
}

export interface TestDataIds {
  domainIds: string[]
  subdomainIds: string[]
  capabilityIds: string[]
  requirementIds: string[]
}

export interface TestDataSet {
  ids: TestDataIds
  domain: { id: string; name: string }
  subdomain: { id: string; name: string }
  capability: { id: string; name: string }
  requirements: Array<{ id: string; reqId: string; title: string }>
}
```

### Step 2: Create Airtable Configuration
**Implements**: TEST-ISO-001
**Files**:
- `tests/e2e/config/airtable.config.ts` - Create new file for test environment config

```typescript
// tests/e2e/config/airtable.config.ts
import * as dotenv from "dotenv"
import * as path from "path"

// Load .env file from project root
dotenv.config({ path: path.resolve(process.cwd(), ".env") })

export const AIRTABLE_CONFIG = {
  apiToken: process.env.VITE_AIRTABLE_API_TOKEN,
  baseId: process.env.VITE_AIRTABLE_BASE_ID,
  baseUrl: `https://api.airtable.com/v0/${process.env.VITE_AIRTABLE_BASE_ID}`,
} as const

if (!AIRTABLE_CONFIG.apiToken || !AIRTABLE_CONFIG.baseId) {
  throw new Error(
    "Missing Airtable configuration. Ensure VITE_AIRTABLE_API_TOKEN and VITE_AIRTABLE_BASE_ID are set in .env"
  )
}

export const TEST_PREFIX = "TEST-"

export const TABLE_NAMES = {
  domain: "Domain",
  subdomain: "Subdomain",
  capability: "Capability",
  requirement: "Requirement",
} as const
```

### Step 3: Create Airtable Client (Infrastructure Layer)
**Implements**: TEST-ISO-001, TEST-ISO-002, TEST-ISO-005
**Files**:
- `tests/e2e/infrastructure/airtable-client.ts` - Create new file with low-level API operations

```typescript
// tests/e2e/infrastructure/airtable-client.ts
import { AIRTABLE_CONFIG } from "../config/airtable.config"

interface AirtableRecord<T> {
  id: string
  fields: T
}

interface AirtableListResponse<T> {
  records: AirtableRecord<T>[]
  offset?: string
}

export class AirtableClient {
  private baseUrl = AIRTABLE_CONFIG.baseUrl
  private headers = {
    Authorization: `Bearer ${AIRTABLE_CONFIG.apiToken}`,
    "Content-Type": "application/json",
  }

  async create<T extends Record<string, unknown>>(
    table: string,
    fields: T
  ): Promise<AirtableRecord<T>> {
    const response = await fetch(`${this.baseUrl}/${table}`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify({ fields }),
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to create record in ${table}: ${error}`)
    }

    return response.json()
  }

  async delete(table: string, recordId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/${table}/${recordId}`, {
      method: "DELETE",
      headers: this.headers,
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to delete record ${recordId} from ${table}: ${error}`)
    }
  }

  async list<T>(
    table: string,
    filterByFormula?: string
  ): Promise<AirtableRecord<T>[]> {
    const params = new URLSearchParams()
    if (filterByFormula) {
      params.set("filterByFormula", filterByFormula)
    }

    const url = `${this.baseUrl}/${table}?${params.toString()}`
    const response = await fetch(url, {
      headers: this.headers,
    })

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Failed to list records from ${table}: ${error}`)
    }

    const data: AirtableListResponse<T> = await response.json()
    return data.records
  }

  async batchDelete(table: string, recordIds: string[]): Promise<void> {
    // Airtable allows max 10 records per batch delete
    const batchSize = 10
    for (let i = 0; i < recordIds.length; i += batchSize) {
      const batch = recordIds.slice(i, i + batchSize)
      const params = batch.map((id) => `records[]=${id}`).join("&")

      const response = await fetch(`${this.baseUrl}/${table}?${params}`, {
        method: "DELETE",
        headers: this.headers,
      })

      if (!response.ok) {
        const error = await response.text()
        throw new Error(`Failed to batch delete from ${table}: ${error}`)
      }
    }
  }
}
```

### Step 4: Create Test Data Repository
**Implements**: TEST-ISO-001, TEST-ISO-002, TEST-ISO-005
**Files**:
- `tests/e2e/repositories/test-data-repository.ts` - Create new file with business logic

```typescript
// tests/e2e/repositories/test-data-repository.ts
import { AirtableClient } from "../infrastructure/airtable-client"
import { TABLE_NAMES, TEST_PREFIX } from "../config/airtable.config"
import type {
  CreateDomainInput,
  CreateSubdomainInput,
  CreateCapabilityInput,
  CreateRequirementInput,
  TestDataIds,
} from "../types/test-data.types"

interface DomainFields {
  Name: string
  Description?: string
}

interface SubdomainFields {
  Name: string
  Domain: string[]
  Prefix?: string
  Description?: string
}

interface CapabilityFields {
  Name: string
  Subdomain: string[]
  Prefix?: string
  Description?: string
}

interface RequirementFields {
  ReqID: string
  Title: string
  Capability: string[]
  Status?: string
  Priority?: string
  Description?: string
}

export class TestDataRepository {
  constructor(private client: AirtableClient) {}

  // Create operations
  async createDomain(input: CreateDomainInput): Promise<string> {
    const record = await this.client.create<DomainFields>(TABLE_NAMES.domain, {
      Name: input.name,
      Description: input.description,
    })
    return record.id
  }

  async createSubdomain(input: CreateSubdomainInput): Promise<string> {
    const record = await this.client.create<SubdomainFields>(TABLE_NAMES.subdomain, {
      Name: input.name,
      Domain: [input.domainId],
      Prefix: input.prefix,
      Description: input.description,
    })
    return record.id
  }

  async createCapability(input: CreateCapabilityInput): Promise<string> {
    const record = await this.client.create<CapabilityFields>(TABLE_NAMES.capability, {
      Name: input.name,
      Subdomain: [input.subdomainId],
      Prefix: input.prefix,
      Description: input.description,
    })
    return record.id
  }

  async createRequirement(input: CreateRequirementInput): Promise<string> {
    const record = await this.client.create<RequirementFields>(TABLE_NAMES.requirement, {
      ReqID: input.reqId,
      Title: input.title,
      Capability: [input.capabilityId],
      Status: input.status,
      Priority: input.priority,
      Description: input.description,
    })
    return record.id
  }

  // Delete operations
  async deleteDomain(id: string): Promise<void> {
    await this.client.delete(TABLE_NAMES.domain, id)
  }

  async deleteSubdomain(id: string): Promise<void> {
    await this.client.delete(TABLE_NAMES.subdomain, id)
  }

  async deleteCapability(id: string): Promise<void> {
    await this.client.delete(TABLE_NAMES.capability, id)
  }

  async deleteRequirement(id: string): Promise<void> {
    await this.client.delete(TABLE_NAMES.requirement, id)
  }

  // Cleanup operations
  async cleanupStaleTestData(): Promise<void> {
    console.log("Cleaning up stale TEST- prefixed data...")

    // Delete in reverse dependency order
    await this.deleteByPrefix(TABLE_NAMES.requirement, "ReqID")
    await this.deleteByPrefix(TABLE_NAMES.capability, "Name")
    await this.deleteByPrefix(TABLE_NAMES.subdomain, "Name")
    await this.deleteByPrefix(TABLE_NAMES.domain, "Name")

    console.log("Stale test data cleanup complete")
  }

  async deleteAll(ids: TestDataIds): Promise<void> {
    console.log("Deleting test data...")

    // Delete in reverse dependency order
    for (const id of ids.requirementIds) {
      await this.deleteRequirement(id).catch((e) => console.warn(`Failed to delete requirement ${id}:`, e))
    }
    for (const id of ids.capabilityIds) {
      await this.deleteCapability(id).catch((e) => console.warn(`Failed to delete capability ${id}:`, e))
    }
    for (const id of ids.subdomainIds) {
      await this.deleteSubdomain(id).catch((e) => console.warn(`Failed to delete subdomain ${id}:`, e))
    }
    for (const id of ids.domainIds) {
      await this.deleteDomain(id).catch((e) => console.warn(`Failed to delete domain ${id}:`, e))
    }

    console.log("Test data deletion complete")
  }

  private async deleteByPrefix(table: string, field: string): Promise<void> {
    const formula = `FIND("${TEST_PREFIX}", {${field}}) = 1`
    const records = await this.client.list<Record<string, unknown>>(table, formula)

    if (records.length > 0) {
      console.log(`Deleting ${records.length} stale records from ${table}`)
      await this.client.batchDelete(
        table,
        records.map((r) => r.id)
      )
    }
  }
}
```

### Step 5: Create Test Data Builder
**Implements**: TEST-ISO-001, TEST-ISO-004
**Files**:
- `tests/e2e/builders/test-data-builder.ts` - Create new file with fluent builder API

```typescript
// tests/e2e/builders/test-data-builder.ts
import { TestDataRepository } from "../repositories/test-data-repository"
import { TEST_PREFIX } from "../config/airtable.config"
import type {
  CreateDomainInput,
  CreateSubdomainInput,
  CreateCapabilityInput,
  CreateRequirementInput,
  TestDataSet,
  TestDataIds,
} from "../types/test-data.types"

function ensurePrefix(name: string): string {
  return name.startsWith(TEST_PREFIX) ? name : `${TEST_PREFIX}${name}`
}

export class TestDataBuilder {
  private domainInput: CreateDomainInput | null = null
  private subdomainInput: Omit<CreateSubdomainInput, "domainId"> | null = null
  private capabilityInput: Omit<CreateCapabilityInput, "subdomainId"> | null = null
  private requirementInputs: Array<Omit<CreateRequirementInput, "capabilityId">> = []

  constructor(private repository: TestDataRepository) {}

  domain(input: CreateDomainInput): this {
    this.domainInput = {
      ...input,
      name: ensurePrefix(input.name),
    }
    return this
  }

  subdomain(input: Omit<CreateSubdomainInput, "domainId">): this {
    this.subdomainInput = {
      ...input,
      name: ensurePrefix(input.name),
    }
    return this
  }

  capability(input: Omit<CreateCapabilityInput, "subdomainId">): this {
    this.capabilityInput = {
      ...input,
      name: ensurePrefix(input.name),
    }
    return this
  }

  requirement(input: Omit<CreateRequirementInput, "capabilityId">): this {
    this.requirementInputs.push({
      ...input,
      reqId: ensurePrefix(input.reqId),
    })
    return this
  }

  async build(): Promise<TestDataSet> {
    if (!this.domainInput) {
      throw new Error("Domain is required. Call domain() before build()")
    }
    if (!this.subdomainInput) {
      throw new Error("Subdomain is required. Call subdomain() before build()")
    }
    if (!this.capabilityInput) {
      throw new Error("Capability is required. Call capability() before build()")
    }
    if (this.requirementInputs.length === 0) {
      throw new Error("At least one requirement is required. Call requirement() before build()")
    }

    console.log("Building test data hierarchy...")

    // Create in dependency order
    const domainId = await this.repository.createDomain(this.domainInput)
    console.log(`Created domain: ${this.domainInput.name} (${domainId})`)

    const subdomainId = await this.repository.createSubdomain({
      ...this.subdomainInput,
      domainId,
    })
    console.log(`Created subdomain: ${this.subdomainInput.name} (${subdomainId})`)

    const capabilityId = await this.repository.createCapability({
      ...this.capabilityInput,
      subdomainId,
    })
    console.log(`Created capability: ${this.capabilityInput.name} (${capabilityId})`)

    const requirements: Array<{ id: string; reqId: string; title: string }> = []
    for (const reqInput of this.requirementInputs) {
      const requirementId = await this.repository.createRequirement({
        ...reqInput,
        capabilityId,
      })
      console.log(`Created requirement: ${reqInput.reqId} (${requirementId})`)
      requirements.push({
        id: requirementId,
        reqId: reqInput.reqId,
        title: reqInput.title,
      })
    }

    const ids: TestDataIds = {
      domainIds: [domainId],
      subdomainIds: [subdomainId],
      capabilityIds: [capabilityId],
      requirementIds: requirements.map((r) => r.id),
    }

    return {
      ids,
      domain: { id: domainId, name: this.domainInput.name },
      subdomain: { id: subdomainId, name: this.subdomainInput.name },
      capability: { id: capabilityId, name: this.capabilityInput.name },
      requirements,
    }
  }
}
```

### Step 6: Create Feature-Specific Data Definition
**Implements**: TEST-ISO-004
**Files**:
- `tests/e2e/data/requirements-viewer.data.ts` - Create new file with test data for requirements viewer feature

```typescript
// tests/e2e/data/requirements-viewer.data.ts
import { TestDataBuilder } from "../builders/test-data-builder"
import type { TestDataSet } from "../types/test-data.types"

export async function createRequirementsViewerTestData(
  builder: TestDataBuilder
): Promise<TestDataSet> {
  return builder
    .domain({
      name: "Education",
      description: "Test domain for E2E testing",
    })
    .subdomain({
      name: "Enrollment",
      prefix: "ENR",
      description: "Test subdomain for enrollment",
    })
    .capability({
      name: "Registration",
      prefix: "REG",
      description: "Test capability for registration",
    })
    .requirement({
      reqId: "REQ-001",
      title: "User can register for courses",
      status: "Godkjent", // Norwegian: Approved
      priority: "Must have",
      description: "Test requirement for E2E",
    })
    .requirement({
      reqId: "REQ-002",
      title: "User can view registration status",
      status: "Utkast", // Norwegian: Draft
      priority: "Should have",
    })
    .build()
}

// Export test data names for use in feature files and steps
export const REQUIREMENTS_VIEWER_TEST_DATA = {
  domain: "TEST-Education",
  subdomain: "TEST-Enrollment",
  capability: "TEST-Registration",
  requirements: {
    first: { reqId: "TEST-REQ-001", title: "User can register for courses" },
    second: { reqId: "TEST-REQ-002", title: "User can view registration status" },
  },
} as const
```

### Step 7: Create Test Data Fixture
**Implements**: TEST-ISO-001, TEST-ISO-002, TEST-ISO-003, TEST-ISO-005
**Files**:
- `tests/e2e/fixtures/test-data.fixture.ts` - Create new file with Playwright worker-scoped fixtures

```typescript
// tests/e2e/fixtures/test-data.fixture.ts
import { test as base } from "playwright-bdd"
import { AirtableClient } from "../infrastructure/airtable-client"
import { TestDataRepository } from "../repositories/test-data-repository"
import { TestDataBuilder } from "../builders/test-data-builder"
import { createRequirementsViewerTestData, REQUIREMENTS_VIEWER_TEST_DATA } from "../data/requirements-viewer.data"
import type { TestDataSet } from "../types/test-data.types"

type TestDataFixtures = {
  testDataRepository: TestDataRepository
  testDataBuilder: TestDataBuilder
  requirementsViewerData: TestDataSet
}

export const test = base.extend<{}, TestDataFixtures>({
  // Worker-scoped repository
  testDataRepository: [
    async ({}, use) => {
      const client = new AirtableClient()
      const repository = new TestDataRepository(client)
      await use(repository)
    },
    { scope: "worker" },
  ],

  // Worker-scoped builder
  testDataBuilder: [
    async ({ testDataRepository }, use) => {
      const builder = new TestDataBuilder(testDataRepository)
      await use(builder)
    },
    { scope: "worker" },
  ],

  // Worker-scoped test data for requirements viewer feature
  requirementsViewerData: [
    async ({ testDataRepository }, use, workerInfo) => {
      console.log(`[Worker ${workerInfo.workerIndex}] Setting up requirements viewer test data...`)

      // 1. Cleanup stale test data from previous runs
      await testDataRepository.cleanupStaleTestData()

      // 2. Create fresh test data
      const client = new AirtableClient()
      const repository = new TestDataRepository(client)
      const builder = new TestDataBuilder(repository)
      const testData = await createRequirementsViewerTestData(builder)

      console.log(`[Worker ${workerInfo.workerIndex}] Test data created successfully`)

      // 3. Provide test data to tests
      await use(testData)

      // 4. Cleanup after all tests in this worker complete
      console.log(`[Worker ${workerInfo.workerIndex}] Cleaning up test data...`)
      await testDataRepository.deleteAll(testData.ids)
      console.log(`[Worker ${workerInfo.workerIndex}] Test data cleaned up`)
    },
    { scope: "worker", auto: true },
  ],
})

export { REQUIREMENTS_VIEWER_TEST_DATA }
```

### Step 8: Update Main Test Fixture
**Implements**: TEST-ISO-001
**Files**:
- `tests/e2e/fixtures/test.ts` - Modify to chain test data fixtures

```typescript
// tests/e2e/fixtures/test.ts
import { RequirementsPage } from "../pages/requirements.page"
import { CompletenessPage } from "../pages/completeness.page"
import { test as testDataTest, REQUIREMENTS_VIEWER_TEST_DATA } from "./test-data.fixture"

type Fixtures = {
  requirementsPage: RequirementsPage
  completenessPage: CompletenessPage
}

export const test = testDataTest.extend<Fixtures>({
  requirementsPage: async ({ page }, use) => {
    const requirementsPage = new RequirementsPage(page)
    await use(requirementsPage)
  },
  completenessPage: async ({ page }, use) => {
    const completenessPage = new CompletenessPage(page)
    await use(completenessPage)
  },
})

export { expect } from "@playwright/test"
export { REQUIREMENTS_VIEWER_TEST_DATA }
```

### Step 9: Update Step Definitions
**Implements**: TEST-ISO-003, TEST-ISO-004
**Files**:
- `tests/e2e/steps/common.steps.ts` - Modify to verify test data exists

```typescript
// tests/e2e/steps/common.steps.ts
import { createBdd } from "playwright-bdd"
import { test } from "../fixtures/test"

const { Given } = createBdd(test)

Given("the test data is loaded", async ({ requirementsPage, requirementsViewerData }) => {
  // Verify test data was created (fixture runs automatically)
  if (!requirementsViewerData) {
    throw new Error("Test data was not created. Check fixture setup.")
  }
  console.log(`Test data available: ${requirementsViewerData.domain.name}`)
})

Given("I am viewing all requirements", async ({ requirementsPage }) => {
  await requirementsPage.goto()
})

Given("I have filters applied", async ({ requirementsPage }) => {
  await requirementsPage.goto()
  // Will be updated to use test data in feature file step
})
```

- `tests/e2e/steps/filter.steps.ts` - Modify to accept concrete values

```typescript
// tests/e2e/steps/filter.steps.ts
import { createBdd } from "playwright-bdd"
import { test } from "../fixtures/test"

const { When } = createBdd(test)

When("I open the requirements viewer", async ({ requirementsPage }) => {
  await requirementsPage.goto()
})

When("I select domain {string}", async ({ requirementsPage }, domainName: string) => {
  await requirementsPage.selectFilter("domain", domainName)
})

When("I select subdomain {string}", async ({ requirementsPage }, subdomainName: string) => {
  await requirementsPage.selectFilter("subdomain", subdomainName)
})

When("I select capability {string}", async ({ requirementsPage }, capabilityName: string) => {
  await requirementsPage.selectFilter("capability", capabilityName)
})

When("I clear all filters", async ({ requirementsPage }) => {
  await requirementsPage.clearAllFilters()
})
```

- `tests/e2e/steps/assertion.steps.ts` - Modify to accept concrete values

```typescript
// tests/e2e/steps/assertion.steps.ts
import { createBdd } from "playwright-bdd"
import { test, expect } from "../fixtures/test"

const { Then } = createBdd(test)

Then("I should see requirements in a table", async ({ requirementsPage }) => {
  await requirementsPage.expectTableToHaveRows(1)
})

Then("I should see {int} requirement(s) in the table", async ({ requirementsPage }, count: number) => {
  const rowCount = await requirementsPage.getTableRowCount()
  expect(rowCount).toBe(count)
})

Then("I should see requirement {string}", async ({ requirementsPage }, reqId: string) => {
  const table = requirementsPage.requirementsTable
  await expect(table).toContainText(reqId)
})

Then("I should not see requirement {string}", async ({ requirementsPage }, reqId: string) => {
  const table = requirementsPage.requirementsTable
  await expect(table).not.toContainText(reqId)
})

Then(
  "the table should display columns: ReqID, Title, Domain, Subdomain, Capability, Status, Priority",
  async ({ requirementsPage }) => {
    await requirementsPage.expectColumnHeaders([
      "ReqID",
      "Title",
      "Domain",
      "Subdomain",
      "Capability",
      "Status",
      "Priority",
    ])
  }
)

Then("I should see only requirements from domain {string}", async ({ requirementsPage }, domainName: string) => {
  // Verify all visible rows have the expected domain
  await requirementsPage.expectFilteredResults()
})

Then("I should see only requirements from subdomain {string}", async ({ requirementsPage }, subdomainName: string) => {
  await requirementsPage.expectFilteredResults()
})

Then("I should see only requirements from capability {string}", async ({ requirementsPage }, capabilityName: string) => {
  await requirementsPage.expectFilteredResults()
})
```

### Step 10: Rewrite Feature File with Concrete Examples
**Implements**: TEST-ISO-004
**Files**:
- `docs/requirements/requirements-viewer/viewer/requirements/view-and-filter-requirements.feature` - Rewrite with concrete test data

```gherkin
@VIW-REQ-001
Feature: View and Filter Requirements
  As a user
  I want to view all requirements and filter them by domain, subdomain, and capability
  So that I can understand the status of requirements across the system

  Background:
    Given the test data is loaded

  Rule: Default view shows all requirements

    Scenario: View all requirements on page load
      When I open the requirements viewer
      Then I should see requirements in a table
      And the table should display columns: ReqID, Title, Domain, Subdomain, Capability, Status, Priority

  Rule: Requirements can be filtered independently

    Scenario: Filter requirements by domain
      When I open the requirements viewer
      And I select domain "TEST-Education"
      Then I should see requirement "TEST-REQ-001"
      And I should see only requirements from domain "TEST-Education"

    Scenario: Filter requirements by subdomain
      When I open the requirements viewer
      And I select subdomain "TEST-Enrollment"
      Then I should see requirement "TEST-REQ-001"
      And I should see only requirements from subdomain "TEST-Enrollment"

    Scenario: Filter requirements by capability
      When I open the requirements viewer
      And I select capability "TEST-Registration"
      Then I should see requirement "TEST-REQ-001"
      And I should see only requirements from capability "TEST-Registration"

    Scenario: Combine multiple filters
      When I open the requirements viewer
      And I select domain "TEST-Education"
      And I select subdomain "TEST-Enrollment"
      Then I should see requirement "TEST-REQ-001"

    Scenario: Clear filters shows all requirements
      Given I am viewing all requirements
      And I select domain "TEST-Education"
      When I clear all filters
      Then I should see requirements in a table
```

### Step 11: Install dotenv dependency
**Implements**: TEST-ISO-001
**Files**:
- `package.json` - Add dotenv as dev dependency

```bash
npm install --save-dev dotenv
```

### Step 12: Update constants file
**Implements**: TEST-ISO-004
**Files**:
- `tests/e2e/support/constants.ts` - Remove hardcoded TEST_DATA, keep routes and timeouts

```typescript
// tests/e2e/support/constants.ts
export const ROUTES = {
  home: "/",
  completeness: "/completeness",
} as const

export const TIMEOUTS = {
  dataLoad: 30_000,
  animation: 500,
} as const
```

## Acceptance Criteria
- [ ] Test data is created before feature file tests run
- [ ] Test data is deleted after feature file tests complete
- [ ] Stale TEST- prefixed data is cleaned up before creating new data
- [ ] Feature file uses concrete test data names (TEST-Education, TEST-REQ-001, etc.)
- [ ] Tests pass with the new test data setup
- [ ] No TEST- prefixed records remain in Airtable after test run completes

## Open Questions
- None - all questions resolved during planning

## Decisions Made
- **Clean Architecture**: Chosen for maintainability and separation of concerns
- **Worker-scoped fixtures**: Data shared across tests in same worker, setup/teardown once per worker
- **TEST- prefix**: Simple, clear identification of test data
- **Cleanup-first strategy**: Handles crashed/interrupted test runs
- **Norwegian status values**: Keep realistic data matching production (Godkjent, Utkast, etc.)
- **Concrete examples in Gherkin**: More readable, self-documenting tests
